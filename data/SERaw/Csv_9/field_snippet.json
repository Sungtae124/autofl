[
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "int PROBE_END_LINE_161",
        "snippet": "int PROBE_END_LINE_161 = 175;\n\n/**\n* Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n* <h3>RFC 4180:</h3>\n* <ul>\n* <li>withDelimiter(',')</li>\n* <li>withQuoteChar('\"')</li>\n* <li>withRecordSeparator(CRLF)</li>\n* </ul>\n* <h3>Additional:</h3>\n* <ul>\n* <li>withIgnoreEmptyLines(true)</li>\n* </ul>\n*/\npublic static final CSVFormat DEFAULT = new CSVFormat(f_comma_4_line_174, f_double_quote_char_5_line_174, null, null, null,\nfalse, true, CRLF, null, null, false);",
        "begin_line": 167,
        "end_line": 183,
        "comment": "\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVRecord} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "int PROBE_START_LINE_177",
        "snippet": "int PROBE_START_LINE_177 = 186;\n\npublic static final org.apache.commons.csv.CSVFormat f_default_3_line_186 = DEFAULT;",
        "begin_line": 185,
        "end_line": 187,
        "comment": "\t\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     * <h3>Additional:</h3>\n     * <ul>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "int PROBE_END_LINE_188",
        "snippet": "int PROBE_END_LINE_188 = 210;\n\n/**\n* Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n* locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n*\n* <p>\n* For example for parsing or generating a CSV file on a French system the following format will be used:\n* </p>\n*\n* <pre>\n* CSVFormat fmt = CSVFormat.newBuilder(EXCEL).withDelimiter(';');",
        "begin_line": 212,
        "end_line": 223,
        "comment": "\t\n     * Comma separated format as defined by <a href=\"http:tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "boolean csvformat1_expr14_line_255",
        "snippet": "boolean csvformat1_expr14_line_255 = csvformat1_expr15_line_255 && csvformat1_expr16_line_255;\nint PROBE_END_LINE_255 = 255;",
        "begin_line": 300,
        "end_line": 301,
        "comment": "    \n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "int PROBE_START_LINE_267",
        "snippet": "int PROBE_START_LINE_267 = 267;\nchar p_delimiter_15_line_267 = delimiter;",
        "begin_line": 314,
        "end_line": 315,
        "comment": "    \n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "final CSVFormat other",
        "snippet": "final CSVFormat other = (CSVFormat) obj;\nif (delimiter != other.delimiter) {\nreturn false;",
        "begin_line": 427,
        "end_line": 429,
        "comment": "    \n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quotePolicy\n     *            the quote policy\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            <tt>true</tt> when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            <tt>true</tt> when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "final StringWriter out",
        "snippet": "final StringWriter out = new StringWriter();\ntry {\nnew CSVPrinter(out, this).printRecord(values);",
        "begin_line": 492,
        "end_line": 494,
        "comment": "    \n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "boolean csvformat1_expr42_line_647",
        "snippet": "boolean csvformat1_expr42_line_647 = csvformat1_expr43_line_647 && csvformat1_expr44_line_647;\nint PROBE_END_LINE_647 = 650;",
        "begin_line": 785,
        "end_line": 786,
        "comment": "    \n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "char f_delimiter_27_line_652",
        "snippet": "char f_delimiter_27_line_652 = delimiter;\nchar csvformat1_expr49_line_652 = commentStart.charValue();",
        "begin_line": 797,
        "end_line": 798,
        "comment": "    \n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVFormat",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVFormat.java",
        "signature": "boolean csvformat1_expr56_line_667",
        "snippet": "boolean csvformat1_expr56_line_667 = csvformat1_expr57_line_667 && csvformat1_expr58_line_667;\nint PROBE_END_LINE_667 = 669;",
        "begin_line": 847,
        "end_line": 848,
        "comment": "    \n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     "
    },
    {
        "class_name": "org.apache.commons.csv.Token",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Token.java",
        "signature": "int PROBE_START_LINE_51",
        "snippet": "int PROBE_START_LINE_51 = 52;\n\norg.apache.commons.csv.Token.Type f_invalid_125_line_52 = INVALID;",
        "begin_line": 51,
        "end_line": 53,
        "comment": "         Token is a comment line. "
    },
    {
        "class_name": "org.apache.commons.csv.Token",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Token.java",
        "signature": "int PROBE_END_LINE_51",
        "snippet": "int PROBE_END_LINE_51 = 52;\n\n/** Token type */\nToken.Type type = f_invalid_125_line_52;",
        "begin_line": 55,
        "end_line": 58,
        "comment": "         Token is a comment line. "
    },
    {
        "class_name": "org.apache.commons.csv.Token",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Token.java",
        "signature": "int PROBE_START_LINE_54",
        "snippet": "int PROBE_START_LINE_54 = 55;\n\nfinal int f_initial_token_length_143_line_55 = INITIAL_TOKEN_LENGTH;",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\t Token type "
    },
    {
        "class_name": "org.apache.commons.csv.Token",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Token.java",
        "signature": "int PROBE_END_LINE_54",
        "snippet": "int PROBE_END_LINE_54 = 55;\n\n/** The content buffer. */\nfinal StringBuilder content = new StringBuilder(f_initial_token_length_143_line_55);",
        "begin_line": 64,
        "end_line": 67,
        "comment": "\t Token type "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_START_LINE_62",
        "snippet": "int PROBE_START_LINE_62 = 62;\norg.apache.commons.csv.ExtendedBufferedReader p_reader_113_line_62 = reader;",
        "begin_line": 62,
        "end_line": 63,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_END_LINE_62",
        "snippet": "int PROBE_END_LINE_62 = 62;\nthis.reader = p_reader_113_line_62;",
        "begin_line": 64,
        "end_line": 65,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_START_LINE_63",
        "snippet": "int PROBE_START_LINE_63 = 63;\norg.apache.commons.csv.CSVFormat p_format_112_line_63 = format;",
        "begin_line": 66,
        "end_line": 67,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "char lexer1_expr3_line_63",
        "snippet": "char lexer1_expr3_line_63 = p_format_112_line_63.getDelimiter();\nint PROBE_END_LINE_63 = 63;",
        "begin_line": 68,
        "end_line": 69,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "Character lexer1_expr12_line_66",
        "snippet": "Character lexer1_expr12_line_66 = p_format_112_line_66.getCommentStart();\nchar lexer1_expr11_line_66 = mapNullToDisabled(lexer1_expr12_line_66);",
        "begin_line": 85,
        "end_line": 86,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_END_LINE_66",
        "snippet": "int PROBE_END_LINE_66 = 66;\nthis.commentStart = lexer1_expr11_line_66;",
        "begin_line": 87,
        "end_line": 88,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "boolean lexer1_expr16_line_68",
        "snippet": "boolean lexer1_expr16_line_68 = p_format_112_line_68.getIgnoreEmptyLines();\nint PROBE_END_LINE_68 = 68;",
        "begin_line": 96,
        "end_line": 97,
        "comment": "     INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_END_LINE_93",
        "snippet": "int PROBE_END_LINE_93 = 93;\n/*\n* Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n* - they are equivalent here.\n*/\nboolean eol = lexer1_expr19_line_93;",
        "begin_line": 130,
        "end_line": 135,
        "comment": "\t\t read the next char and set eol"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_END_LINE_96",
        "snippet": "int PROBE_END_LINE_96 = 109;\n// empty line detection: eol AND (last char was EOL or beginning)\nif (f_ignore_empty_lines_120_line_96) {\nwhile (eol && isStartOfLine(lastChar)) {\n// go on char ahead ...\nlastChar = c;",
        "begin_line": 139,
        "end_line": 144,
        "comment": "\t\t/*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         "
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "boolean lexer1_expr26_line_112",
        "snippet": "boolean lexer1_expr26_line_112 = true;\nif (lexer1_expr24_line_112) {\nint v_c_123_line_112 = c;",
        "begin_line": 163,
        "end_line": 165,
        "comment": "                     don't set token.isReady here because no content"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "boolean lexer1_expr27_line_118",
        "snippet": "boolean lexer1_expr27_line_118 = lexer1_expr28_line_118 && lexer1_expr29_line_118;\nint PROBE_END_LINE_118 = 129;",
        "begin_line": 188,
        "end_line": 189,
        "comment": "             don't set token.isReady here because no content"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "final String line",
        "snippet": "final String line = reader.readLine();\nif (line == null) {\ntoken.type = EOF;",
        "begin_line": 191,
        "end_line": 193,
        "comment": "             don't set token.isReady here because no content"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "final String comment",
        "snippet": "final String comment = line.trim();\ntoken.content.append(comment);",
        "begin_line": 197,
        "end_line": 198,
        "comment": "                 don't set token.isReady here because no content"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "boolean lexer1_expr30_line_132",
        "snippet": "boolean lexer1_expr30_line_132 = f_type_81_line_132 == f_invalid_125_line_132;\nint PROBE_END_LINE_132 = 162;",
        "begin_line": 207,
        "end_line": 208,
        "comment": "                 don't set token.isReady here because no content"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_START_LINE_134",
        "snippet": "int PROBE_START_LINE_134 = 139;\nboolean f_ignore_surrounding_spaces_119_line_134 = ignoreSurroundingSpaces;",
        "begin_line": 211,
        "end_line": 212,
        "comment": "\t\t important: make sure a new char gets consumed in each iteration"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_END_LINE_134",
        "snippet": "int PROBE_END_LINE_134 = 139;\n// ignore whitespaces at beginning of a token\nif (f_ignore_surrounding_spaces_119_line_134) {\nwhile (isWhitespace(c) && !eol) {\nc = reader.read();",
        "begin_line": 213,
        "end_line": 217,
        "comment": "\t\t important: make sure a new char gets consumed in each iteration"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "boolean lexer1_expr36_line_191",
        "snippet": "boolean lexer1_expr36_line_191 = isEndOfFile(p_ch_127_line_191);\nint PROBE_END_LINE_191 = 209;",
        "begin_line": 290,
        "end_line": 291,
        "comment": "         Faster to use while(true)+break than while(token.type == INVALID)"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "int PROBE_START_LINE_291",
        "snippet": "int PROBE_START_LINE_291 = 291;\nCharacter p_c_130_line_291 = c;",
        "begin_line": 399,
        "end_line": 400,
        "comment": "                 consume character"
    },
    {
        "class_name": "org.apache.commons.csv.Lexer",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Lexer.java",
        "signature": "char lexer1_expr45_line_291",
        "snippet": "char lexer1_expr45_line_291 = ' ';\nif (lexer1_expr44_line_291) {\nf_disabled_131_line_291 = DISABLED;",
        "begin_line": 403,
        "end_line": 405,
        "comment": "                 consume character"
    },
    {
        "class_name": "org.apache.commons.csv.Constants",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Constants.java",
        "signature": "int PROBE_START_LINE_36",
        "snippet": "int PROBE_START_LINE_36 = 36;\n\nstatic final Character constants1_expr1_line_36 = Character.valueOf('\"');",
        "begin_line": 36,
        "end_line": 38,
        "comment": "    \n     * Starts a comment, the remainder of the line is the comment.\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVRecord",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVRecord.java",
        "signature": "int PROBE_START_LINE_53",
        "snippet": "int PROBE_START_LINE_53 = 53;\nlong p_record_number_90_line_53 = recordNumber;",
        "begin_line": 54,
        "end_line": 55,
        "comment": "     The values of the record "
    },
    {
        "class_name": "org.apache.commons.csv.CSVRecord",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVRecord.java",
        "signature": "int PROBE_END_LINE_53",
        "snippet": "int PROBE_END_LINE_53 = 53;\nthis.recordNumber = p_record_number_90_line_53;",
        "begin_line": 56,
        "end_line": 57,
        "comment": "     The values of the record "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_START_LINE_174",
        "snippet": "int PROBE_START_LINE_174 = 174;\nString p_string_59_line_174 = string;",
        "begin_line": 174,
        "end_line": 175,
        "comment": "    \n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_END_LINE_174",
        "snippet": "int PROBE_END_LINE_174 = 174;\nAssertions.notNull(p_string_59_line_174, \"string\");",
        "begin_line": 176,
        "end_line": 177,
        "comment": "    \n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "private final Token reusableToken",
        "snippet": "private final Token reusableToken = new Token();\n\n/**\n* Customized CSV parser using the given {@link CSVFormat}\n*\n* <p>\n* If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n* unless you close the {@code reader}.\n* </p>\n*\n* @param reader\n*            a Reader containing CSV-formatted input. Must not be null.\n* @param format\n*            the CSVFormat used for CSV parsing. Must not be null.\n* @throws IllegalArgumentException\n*             If the parameters of the format are inconsistent or if either reader or format are null.\n* @throws IOException\n*             If there is a problem reading the header or skipping the first record\n*/\npublic CSVParser(final Reader reader, final CSVFormat format) throws IOException {\nint PROBE_START_LINE_242 = 242;",
        "begin_line": 232,
        "end_line": 252,
        "comment": "     A record buffer for getRecord(). Grows as necessary and is reused. "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_END_LINE_242",
        "snippet": "int PROBE_END_LINE_242 = 242;\nAssertions.notNull(p_reader_66_line_242, \"reader\");",
        "begin_line": 254,
        "end_line": 255,
        "comment": "    \n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_END_LINE_243",
        "snippet": "int PROBE_END_LINE_243 = 243;\nAssertions.notNull(p_format_67_line_243, \"format\");",
        "begin_line": 258,
        "end_line": 259,
        "comment": "    \n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "final String[] formatHeader",
        "snippet": "final String[] formatHeader = csvparser1_expr29_line_359;\nint PROBE_START_LINE_360 = 387;",
        "begin_line": 409,
        "end_line": 410,
        "comment": "    \n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_START_LINE_388",
        "snippet": "int PROBE_START_LINE_388 = 388;\nMap<String, Integer> v_hdr_map_75_line_388 = hdrMap;",
        "begin_line": 442,
        "end_line": 443,
        "comment": "             build the name to index mappings"
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_END_LINE_409",
        "snippet": "int PROBE_END_LINE_409 = 409;\nreturn csvparser1_expr35_line_409;",
        "begin_line": 472,
        "end_line": 473,
        "comment": "    \n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     "
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_START_LINE_428",
        "snippet": "int PROBE_START_LINE_428 = 430;\nboolean csvparser1_expr37_line_428 = CSVParser.this.isClosed();",
        "begin_line": 492,
        "end_line": 493,
        "comment": "                     TODO: This is not great, throw an ISE instead?"
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_END_LINE_428",
        "snippet": "int PROBE_END_LINE_428 = 430;\nif (csvparser1_expr37_line_428) {\nthrow new NoSuchElementException(\"CSVParser has been closed\");",
        "begin_line": 494,
        "end_line": 496,
        "comment": "                     TODO: This is not great, throw an ISE instead?"
    },
    {
        "class_name": "org.apache.commons.csv.CSVParser",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/CSVParser.java",
        "signature": "int PROBE_START_LINE_431",
        "snippet": "int PROBE_START_LINE_431 = 431;\nCSVRecord csvparser1_expr39_line_431 = this.current;",
        "begin_line": 498,
        "end_line": 499,
        "comment": "                     TODO: This is not great, throw an ISE instead?"
    },
    {
        "class_name": "org.apache.commons.csv.Assertions",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Assertions.java",
        "signature": "int PROBE_START_LINE_32",
        "snippet": "int PROBE_START_LINE_32 = 34;\nObject p_parameter_1_line_32 = parameter;",
        "begin_line": 32,
        "end_line": 33,
        "comment": "         can not be instantiated"
    },
    {
        "class_name": "org.apache.commons.csv.Assertions",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/Assertions.java",
        "signature": "boolean assertions1_expr1_line_32",
        "snippet": "boolean assertions1_expr1_line_32 = p_parameter_1_line_32 == null;\nint PROBE_END_LINE_32 = 34;",
        "begin_line": 34,
        "end_line": 35,
        "comment": "         can not be instantiated"
    },
    {
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/ExtendedBufferedReader.java",
        "signature": "int PROBE_START_LINE_39",
        "snippet": "int PROBE_START_LINE_39 = 40;\n\nprivate int f_undefined_104_line_40 = UNDEFINED;",
        "begin_line": 39,
        "end_line": 41,
        "comment": "\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}.\n *\n * @version $Id$\n "
    },
    {
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/ExtendedBufferedReader.java",
        "signature": "int PROBE_END_LINE_39",
        "snippet": "int PROBE_END_LINE_39 = 40;\n\n/** The last char returned */\nprivate int lastChar = f_undefined_104_line_40;",
        "begin_line": 43,
        "end_line": 46,
        "comment": "\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}.\n *\n * @version $Id$\n "
    },
    {
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/ExtendedBufferedReader.java",
        "signature": "private long eolCounter",
        "snippet": "private long eolCounter = 0;\n\nprivate boolean closed;",
        "begin_line": 49,
        "end_line": 51,
        "comment": "     The count of EOLs (CR/LF/CRLF) seen so far "
    },
    {
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "src_path": "/data/bug_db/subjects/defects4j/Csv-9/result/src/org/apache/commons/csv/ExtendedBufferedReader.java",
        "signature": "boolean extended_buffered_reader1_expr8_line_57",
        "snippet": "boolean extended_buffered_reader1_expr8_line_57 = current == f_lf_12_line_57;\nboolean extended_buffered_reader1_expr9_line_57 = true;",
        "begin_line": 73,
        "end_line": 74,
        "comment": "    \n     * Created extended buffered reader using default buffer-size\n     "
    }
]